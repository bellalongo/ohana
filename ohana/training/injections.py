import numpy as np
from tqdm import tqdm

def get_saturation_level_elec(gain, saturation_level_pxs):
    """
        * return the saturation level in electrons for a given SCA ID
    """
    saturation_e = saturation_level_pxs * gain

    return saturation_e

def generate_baseline_ramp(shape, num_frames, read_time, gain, saturation_level_counts, 
                           dark_current, read_noise, extra_gaussian_noise_dn):
    """
    Simulates a more realistic baseline up-the-ramp signal (in counts) 
    with dark current and noise.

    Args:
        shape (tuple): (height, width) of the detector.
        num_frames (int): Number of frames in the ramp.
        read_time (float): Time to read a single frame in seconds.
        gain (float): Detector gain in e-/ADU.
        saturation_level_counts (float): DN value at which saturation occurs.
        dark_current (float): Dark current in electrons per second.
        read_noise (float): Read noise in electrons (standard deviation).
        extra_gaussian_noise_dn (float): Additional Gaussian noise in DN.

    Returns:
        np.ndarray: Ramp data of shape (num_frames, height, width), in counts.
    """
    height, width = shape
    
    # Electrons generated by dark current during a single frame's integration time
    dark_signal_per_frame_e = dark_current * read_time
    
    # Initialize the accumulated signal in electrons for all pixels
    accumulated_signal_e = np.zeros((height, width), dtype=np.float32)
    
    # Create an empty data cube to store the ramp data in counts (DN)
    ramp_data_dn = np.zeros((num_frames, height, width), dtype=np.float32)

    # Loop through each frame to simulate the signal accumulation
    for i in range(num_frames):
        # Add the dark signal accumulated during this single frame
        accumulated_signal_e += dark_signal_per_frame_e
        
        # For this frame's readout, add the read noise to the currently accumulated signal
        readout_signal_e = accumulated_signal_e + np.random.normal(0, read_noise, size=shape)
        
        # Convert the total signal plus noise to counts (DN)
        ramp_data_dn[i, :, :] = readout_signal_e / gain

    # Add any extra Gaussian noise after the conversion to DN
    if extra_gaussian_noise_dn > 0:
        ramp_data_dn += np.random.normal(0, extra_gaussian_noise_dn, size=ramp_data_dn.shape)

    # Clip the final ramp data to the specified saturation level
    ramp_data_dn = np.clip(ramp_data_dn, 0, saturation_level_counts)

    return ramp_data_dn

def inject_cosmic_ray(ramps, position, frame_idx, 
                      charge_e, gain, saturation_level_counts):
    """
        Inject a cosmic ray as a step function at a specific frame and pixel.
        
        Args:
            charge_e (float): Total electrons to inject for the cosmic ray.
    """
    charge_dn = charge_e / gain
    
    # Add the charge to all frames from the impact frame onward
    ramps[frame_idx:, position[0], position[1]] += charge_dn
    
    # Clip the data to the saturation level
    ramps[:] = np.clip(ramps, 0, saturation_level_counts)

def inject_rtn(ramps, position, high_offset_e, period, duty_fraction, gain, saturation_level_counts):
    """
    Injects a two-level Random Telegraph Noise (RTN) into a specified pixel of the ramp
    using a two-state Markov model.

    Args:
        ramps (np.ndarray): The data cube of shape (n_reads, height, width).
        position (tuple): (row, col) index of the pixel to modify.
        high_offset_e (float): The amplitude of the high state in electrons.
        period (int): The total period (T) of one on/off cycle in frames.
        duty_fraction (float): The fraction of the period (f) spent in the high state.
        gain (float): Gain in electrons per DN (e‚Åª/DN).
        saturation_level_counts (float): Maximum allowed DN value to clip the signal to.
    """
    high_offset_dn = high_offset_e / gain
    num_frames = ramps.shape[0]
    
    # Determine the duration for the 'up' and 'down' states of the noise
    up_time = int(period * duty_fraction)
    down_time = int(period * (1 - duty_fraction))

    # If either state has zero duration, no RTN is injected
    if up_time == 0 or down_time == 0:
        return

    # Randomly choose whether the pixel starts in the high or low state
    is_high = np.random.choice([True, False])
    t = 0
    while t < num_frames:
        time_in_state = up_time if is_high else down_time
        end_frame = min(t + time_in_state, num_frames)
        
        if is_high:
            ramps[t:end_frame, position[0], position[1]] += high_offset_dn
        
        t = end_frame
        is_high = not is_high

    np.clip(ramps, 0, saturation_level_counts, out=ramps)

def inject_snowball(ramps, center, radius, 
                                 core_charge_e, halo_profile_e, gain, 
                                 saturation_level_counts, impact_frame):
    """
    Inject a realistic snowball into a ramp at a specific frame.

    Args:
        ramps (np.ndarray): Ramp cube (n_reads, height, width).
        center (tuple): (y, x) position of snowball.
        radius (float): Radius of the saturated core in pixels.
        core_charge_e (float): Charge in electrons (e-) for the saturated core.
        halo_profile_e (callable): A function that takes distance and returns charge in e- for the halo.
        gain (float): Detector gain in e-/DN.
        saturation_level_counts (float): Maximum pixel value (DN).
        impact_frame (int): Frame index when the snowball hits.
    """
    h, w = ramps.shape[1:]
    Y, X = np.ogrid[:h, :w]
    distance = np.sqrt((X - center[1])**2 + (Y - center[0])**2)

    # Mask for the saturated core of the snowball
    core_mask = distance < radius

    # Define the extent of the halo, extending from the core edge
    max_halo_extent_pixels = 150 
    halo_mask = (distance >= radius) & (distance < radius + max_halo_extent_pixels)

    # Convert charges from electrons to DN
    core_dn = core_charge_e / gain
    halo_e = halo_profile_e(distance[halo_mask])
    halo_dn = halo_e / gain

    # Inject the core and halo charge into all frames from the impact onward
    ramps[impact_frame:, core_mask] += core_dn
    ramps[impact_frame:, halo_mask] += halo_dn

    # Clip the final ramp values to the saturation level
    np.clip(ramps, 0, saturation_level_counts, out=ramps)
